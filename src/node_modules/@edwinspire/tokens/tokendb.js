const path = require("path");
const fs = require('fs').promises;
const fsNormal = require('fs');
const { TOKEN_ENCRYPT } = process.env;
const jwt = require('jsonwebtoken');
const {
    createHash,
} = require('crypto');



export class Token {

    constructor() {
        this._path_token = "tmptoken";
    }

    all() {
        let tokens = {};
        if (fsNormal.existsSync(this._path_token)) {
            fsNormal.readdirSync(this._path_token).forEach((username, index) => {
                var curPath = path.join(this._path_token, username);


                if (fsNormal.lstatSync(curPath).isDirectory()) { // recurse

                    console.log(curPath);
                    let tokensUser = fsNormal.readdirSync(curPath).map((tokenfile) => {
                        let t = path.join(curPath, tokenfile);
                        console.log(t, fsNormal.lstatSync(t));
                        if (fsNormal.lstatSync(t).isFile()) {
                            try {
                                return JSON.parse(fsNormal.readFileSync(t, "utf8"))
                            } catch (error) {
                                console.error(error);
                            }
                        }
                    });

                    console.log(tokensUser);
                    tokens[username] = tokensUser;
                }

            });
            
        } else {
            console.log('No hay carpetas en ' + this._path_token);
        }
        return tokens;
    }

    async read(token) {
        let data;
        try {
            const user = jwt.verify(token, TOKEN_ENCRYPT);
            data = JSON.parse(await fs.readFile(this._file_token(user.username, user.idtoken)));
            //console.log(data);
        } catch (error) {
            console.log(error)
        }
        return data;
    }

    deleteAll() {
        this._rmDir(this._path_token);
    }

    _file_token(username, idtoken) {
        return path.join(this._path_token, username, idtoken + '.token');
    }

    _user_path(username) {
        return path.join(this._path_token, username);
    }

    _create_user_dir(username) {

        if (!fsNormal.existsSync(this._path_token)) {
            fsNormal.mkdirSync(this._path_token);
        }
        let UserDir = this._user_path(username);
        if (!fsNormal.existsSync(UserDir)) {
            fsNormal.mkdirSync(UserDir);
        }
        return UserDir;
    }

    async save(token) {
        let r;
        try {

            const user = jwt.verify(token, TOKEN_ENCRYPT);
            if (user.multilogin == false) {
                this.deleteByUser(user.username);
            }

            this._create_user_dir(user.username);
            await fs.writeFile(this._file_token(user.username, user.idtoken), JSON.stringify(user, null, 4)); // need to be in an async function
            r = true;
        } catch (error) {
            console.log(error)
        }
    }


    async token(request, uniq_username, fullname, multilogin, profile, payload) {
        let t;
        if (uniq_username) {
            multilogin = multilogin || false;
            let ip = request.headers['x-forwarded-for'] || request.connection.remoteAddress;
            let device;

            const hash = createHash('sha256');
            hash.update(JSON.stringify(ip) + JSON.stringify(request.headers['user-agent']));
            device = hash.digest('hex');

            if (device) {

                let UserSignin = {
                    device: device,
                    username: uniq_username,
                    multilogin: multilogin,
                    profile: profile,
                    payload: payload,
                    fullname: fullname || uniq_username,
                    idtoken: Math.random()
                };

                t = jwt.sign(UserSignin, TOKEN_ENCRYPT, { expiresIn: '2h' });
                await this.save(t);
            }

        } else {
            throw 'uniq_username not found';
        }
        return t;
    }

    _dirUser(username) {
        return path.join(this._path_token, username);
    }

    _rmDir(dir) {

        if (fsNormal.existsSync(dir)) {
            fsNormal.readdirSync(dir).forEach((file, index) => {
                var curPath = path.join(dir, file);
                //console.log(curPath);
                if (fsNormal.lstatSync(curPath).isDirectory()) { // recurse
                    this._rmDir(curPath);
                } else { // delete file
                    fsNormal.unlinkSync(curPath);
                }
            });
            fsNormal.rmdirSync(dir);
        }
    };

    deleteByUser(username) {
        this._rmDir(this._user_path(username));
    }

    async verify(itoken) {
        let user = null;
        try {

            user = jwt.verify(itoken, TOKEN_ENCRYPT);
            let data = await this.read(itoken);
            if (data === undefined) {
                user = null;
            }

        } catch (err) {
            console.error(err.message, itoken);
            await this.delete(itoken);
        }

        return user;
    }

    async delete(itoken) {

        try {
            var user = jwt.decode(itoken, { complete: false });
            console.log(user);
            if (user) {

                if (user.multilogin) {
                    await fs.unlink(this._file_token(user.username, user.idtoken));
                } else {
                    this.deleteByUser(user.username);
                }

            }
        } catch (error) {
            console.log(error);
        }
    }



}