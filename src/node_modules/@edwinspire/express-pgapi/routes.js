require('dotenv').config({ override: true });
const { TOKEN_ENCRYPT } = process.env;
const Router = require('express-promise-router')
const db = require('@edwinspire/express-pgapi/pgexpress')
const fetch = require('node-fetch');
const passport = require('passport');
//const LocalStrategy = require('passport-local');
const jwt = require('jsonwebtoken');

var pushSubscription;
const router = new Router();

//console.log(TOKEN_ENCRYPT);

async function fnAccessPoint(req, res) {

    let toke_user = req.cookies['TOKEN_USER'];
    let user = false;
    try {
        user = jwt.verify(toke_user, TOKEN_ENCRYPT);
    } catch (err) {
        console.error(err.message);
    }

    const myURL = new URL('https://' + req.hostname + req.originalUrl);
    let ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    let idata = {
        cookies: req.cookies,
        body: req.body,
        query: req.query,
        method: req.method,
        pathname: myURL.pathname,
        ipclient: ip,
        headers: req.headers,
        user: user
    }

    if (req.headers.authorization && req.headers.authorization.indexOf('Basic ') >= 0) {
        const base64Credentials = req.headers.authorization.split(' ')[1];
        const credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');
        const [username, password] = credentials.split(':');
        idata.headers.BasicAuthentication = { username: username, password: password };
    }

    try {
        let query = {
            name: idata.method,
            text: `SELECT api.fn_access_point($1::JSON)`,
            values: [JSON.stringify(idata)]
        }
        let respg = await db.query(query);

        if (respg.rows.length > 0) {
            let r = respg.rows[0].fn_access_point;

            if (r.data && r.data.token_subscription) {
                res.cookie('TOKEN_SUBSCRIPTION', r.data.token_subscription, {
                    //maxAge: 86400 * 1000
                    expire: 3600 * 1000 * 24 * 365 * 50 // Expira en 10 años
                    //httpOnly: true
                });
            }

            if (r.status == '401') {
                res.status(401).location('/').end();
            } else {
                res.status(r.status).json(r.data);
            }

        } else {
            res.status(204).json([]);
        }
    } catch (e) {
        console.error(e);
        res.status(500).json(e);
    }
}



router.post('/pgapi/signin1', function (req, res, next) {

    passport.authenticate('local', (err, user, info) => {
        console.log(err, user, info);
        if (err) { return res.status(500).json(err); }
        if (!user) { return res.status(401).json(info); }
        return res.status(200).json(user);
    })(req, res, next);
});

router.post('/pgapi/signin2', function (req, res, next) {
    passport.authenticate('local', (err, user, info) => {
        console.log('AQUI >>>', err, user, info);
        if (err) { return res.status(500).json(err); }
        if (!user) { return res.status(401).json(err); }
        req.logIn(user, (err) => {
            if (err) { console.error(err); return next(err); }
            //console.log(req.isAuthenticated(), res.session);
            /*
            res.cookie('TOKEN_USER', user, {
                //maxAge: 86400 * 1000
                expire: 3600 * 1000 * 24 * 365 * 50 // Expira en 10 años, sin ambargo internamente el token tiene su propia fecha de expiración
                //httpOnly: true
            });
            */
            return res.status(200).json(user);
        });
    })(req, res, next);
});

router.post('/pgapi/signin',
    passport.authenticate('local', { session: false }),
    function (req, res) {

        res.cookie('TOKEN_USER', jwt.sign(req.user, TOKEN_ENCRYPT, { expiresIn: '1h' }), {
            //maxAge: 86400 * 1000
            expire: 3600 * 1000 * 24 * 365 * 50 // Expira en 10 años, sin ambargo internamente el token tiene su propia fecha de expiración
            //httpOnly: true
        });

        res.json(req.user);
    });

router.post('/pgapi/signin3', function (req, res, next) {
    passport.authenticate('local', (err, user, info) => {
        console.log('AQUI >>>', err, user, info);
        if (err) { return res.status(500).json(err); }
        if (!user) { return res.status(401).json(err); }
        req.logIn(user, (err) => {
            if (err) { console.error(err); return next(err); }
            //console.log(req.isAuthenticated(), res.session);
            /*
            res.cookie('TOKEN_USER', user, {
                //maxAge: 86400 * 1000
                expire: 3600 * 1000 * 24 * 365 * 50 // Expira en 10 años, sin ambargo internamente el token tiene su propia fecha de expiración
                //httpOnly: true
            });
            */
            return res.status(200).json(user);
        });
    })(req, res, next);
});





/*
router.post('/pgapi/signin',
    passport.authenticate('local', {
        successRedirect: '/este/yamismo',
        failureRedirect: '/este/yamismo'
    }));


    router.get('/este/yamismo', function (req, res) {
        console.log('Ya mismo', req.isAuthenticated(), res.user, req.user);
        res.status(200).json({hola: 0});
    });
*/



router.get('/pgapi/signout', function (req, res) {
    req.logout();    
    res.cookie('TOKEN_USER', jwt.sign({signout: true}, TOKEN_ENCRYPT, { expiresIn: 1 }), {
        expire: 0
    });
    res.redirect('/');
});



router.get('/pgapi/test', function (req, res) {
    let toke_user = req.cookies['TOKEN_USER'];
    let user = 'No autenticado';
    try {
        user = jwt.verify(toke_user, TOKEN_ENCRYPT);
    } catch (err) {
        console.error(err.message);
    }
    res.status(200).json({ hola: req.isAuthenticated(), userSession: req.user, chao: 've', 'cook':  user});
});


/*
router.post('/pgapi/signin', 
passport.authenticate('local', { failureFlash: true }));
*/
/*
router.all('/pgapi/signin', async (req, res) => {

    
passport.authenticate('passport-pg');


    var token = jwt.sign({ foo: 'bar' }, TOKEN_ENCRYPT, { expiresIn: 60 });
    res.cookie('TOKEN_USER', token, {
        expire: 3600 * 1000 * 24 * 365 * 50 // Expira en 10 años
        //httpOnly: true
    });
    // invalid token - synchronous
    try {
        var decoded = jwt.verify(token, TOKEN_ENCRYPT);
        res.status(200).json(decoded);
    } catch (err) {
        // err
        res.status(500).json(err);
    }



    //pushSubscription = req.body;
    //fnAccessPoint(req, res);

});
*/

// create a new express-promise-router
// this has the same API as the normal express router except
// it allows you to use async functions as route handlers
// export our router to be mounted by the parent application

router.all('/pgapi/*', async (req, res) => {
    fnAccessPoint(req, res);
})



// Para subscribir usuarios web-push
router.post('/webpush-subscription', async (req, res) => {
    pushSubscription = req.body;
    fnAccessPoint(req, res);
});


// Para subscribir usuarios web-push
router.get('/push', async (req, res) => {
    console.log('pushSubscription2 =>> ' + pushSubscription);
    res.status(200).json({ 'pushSubscription': pushSubscription });
})





router.all('/Test/EstadoDocumentosElectronicos', (req, res) => {
    var url = 'https://www.crcind.com/csp/samples/SOAP.Demo.cls?wsdl';
    var args = { Arg1: 12, Arg2: 1000 };
    soap.createClient(url, (err, client) => {
        client.AddInteger(args, (err, result) => {
            console.log(result);
            req.body = result;
            console.log(result);
            fnAccessPoint(req, res);
        });
    });
});

module.exports = router;
